/*
문제
45656이란 수를 보자.
이 수는 인접한 모든 자리의 차이가 1이다. 
이런 수를 계단 수라고 한다.

N이 주어질 때, 길이가 N인 계단 수가 총 몇 개 있는지 구해보자. 
0으로 시작하는 수는 계단수가 아니다.

입력
첫째 줄에 N이 주어진다. 
N은 1보다 크거나 같고, 100보다 작거나 같은 자연수이다.
(1 <= N <= 100)

출력
첫째 줄에 정답을 1,000,000,000으로 나눈 나머지를 출력한다.

len = 자리 수
d = 1의 자리 값 0~9
dp[len][d]
dp[1][0] = 0
dp[1][1]~dp[1][9] = 1
1 2 3 4 5 6 7 8 9
dp[2][i]       dp[2][i] = dp[1][i] * 2 + dp[1][0] + dp[1][9]
10 12 21 23 32 34 ... 87 89 98
dp[3][i] = dp[2][i] * 2 + dp[2][0] + dp[2][9]
dp[n][0] -> __10 
*/

#include <iostream>
#include <vector>
using namespace std;

int N;
long long dp[101][10] = {0};
const long long MOD = 1e9;

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> N;
    
    dp[1][0] = 0;
    for(int i = 1; i <= 9; ++i){
        dp[1][i] = 1;
    }
    for(int n = 2;n <=N; ++n){
        for(int i = 0; i <=9; ++i){
            if(i == 0)
                dp[n][i] = dp[n-1][1];
            else if (i == 9)
                dp[n][i] = dp[n-1][8];
            else
                dp[n][i] = dp[n-1][i-1] + dp[n-1][i+1];
            dp[n][i] %= MOD;
        }
    }
    
    long long sum = 0;
    
    for(int i=0;i<10; ++i){
        sum = (sum + dp[N][i]) % MOD;
    }
    cout << sum;

    return 0;
}