/*
문제
그래프의 정점의 집합을 둘로 분할하여, 
각 집합에 속한 정점끼리는 서로 인접하지 않도록 분할할 수 있을 때, 
그러한 그래프를 특별히 이분 그래프 (Bipartite Graph) 라 부른다.

그래프가 입력으로 주어졌을 때, 이 그래프가 이분 그래프인지 아닌지 판별하는 프로그램을 작성하시오.

입력
입력은 여러 개의 테스트 케이스로 구성되어 있는데, 첫째 줄에 테스트 케이스의 개수 K가 주어진다. 
각 테스트 케이스의 첫째 줄에는 그래프의 정점의 개수 V와 간선의 개수 E가 빈 칸을 사이에 두고 순서대로 주어진다.
각 정점에는 1부터 V까지 차례로 번호가 붙어 있다. 
이어서 둘째 줄부터 E개의 줄에 걸쳐 간선에 대한 정보가 주어지는데, 
각 줄에 인접한 두 정점의 번호 u, v (u ≠ v)가 빈 칸을 사이에 두고 주어진다. 

출력
K개의 줄에 걸쳐 입력으로 주어진 그래프가 이분 그래프이면 YES, 아니면 NO를 순서대로 출력한다.

제한
2 ≤ K ≤ 5
1 ≤ V ≤ 20,000
1 ≤ E ≤ 200,000

예제
2
3 2

1 3
2 3 -> 
1: {3} 
2: {3} 
3: {1,2}

4 4

1 2
2 3
3 4
4 2

graph[1] = {2}
graph[2] = {3,4}
graph[3] = {2,4}
graph[4] = {2,3} 얘네들이 문제

어떤 값을 기준으로 분할해본다.
{1,3} {2,3}
*/

#include <iostream>
#include <vector>
#include <queue>
using namespace std;

vector<int> graph[20001];
int visited[20001];
int V, E;

bool isBinary = true;

void bfs(int start){
    queue<int> q;
    visited[start] = 1;
    q.push(start);

    while(!q.empty()){
        int cur = q.front(); q.pop();

        for(int next : graph[cur]){
            if(visited[next] == visited[cur]){
                isBinary = false;
                return;
            }

            if(visited[next] == 0){
                visited[next] = visited[cur] % 2 + 1;
                q.push(next);
            }
        }
    }
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int K;      // Test Case
    cin >> K;

    while(K--){
        cin >> V >> E;

        // graph 초기화 먼저
        for(int i = 0; i < 20001; ++i){
            graph[i].clear();
            visited[i] = 0;
        }
        isBinary = true;

        // graph[v] : v번 정점에 연결된 다른 vertex들을 들고있음 (1~20000)
        for(int i = 0; i < E; ++i){
            int u, v;
            cin >> u >> v;

            graph[u].push_back(v);
            graph[v].push_back(u);
        }

        for(int i = 1; i <= V; ++i){
            if(!isBinary) break;
            if(visited[i] == 0)
                bfs(i);
        }

        cout << (isBinary ? "YES\n" : "NO\n");
    }

    return 0;
}