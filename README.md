# CodingTestPractice
코딩테스트 연습장 🧠💻

매일 2~3문제씩 꾸준히 풀면서,
난이도를 조금씩 올려가며 실력을 쌓기 위한 코딩테스트 연습 저장소입니다.

---

## 🎯 목표 (Goals)

- 하루 **2~3문제** 이상 꾸준히 풀이
- **쉬운 문제 → 중간 난이도 → 어려운 문제** 순으로 단계적으로 난이도 상승
- 단순 정답 코드가 아니라,  
  - 왜 이렇게 풀었는지  
  - 어떤 점에서 막혔는지  
  - 다음엔 어떻게 더 잘 풀 수 있을지  
  를 기록하면서 실력과 사고력을 함께 성장시키기
- 나의 학습 히스토리를 GitHub에 남겨 **성장 로그(타임라인)** 만들기

---

## 📅 학습 규칙 (Study Rules)

1. **매일 최소 2문제 이상** 풀기  
   - 여유가 되면 3문제 이상 도전
2. 한 문제를 풀 때:
   - 먼저 **손코딩/메모**로 접근 아이디어 생각하기
   - 바로 답을 찾지 말고, 최소 **10~20분은 스스로 고민**해 보기
3. 풀지 못한 문제는
   - 풀이를 본 뒤 **반드시 직접 다시 구현**해 보기
   - `다시 풀기` 체크를 남겨서 나중에 재도전
4. 같은 유형의 문제는 **3~5개 이상 연속으로** 풀어보기
5. 하루가 끝날 때, **오늘 배운 개념/실수 정리**를 짧게 기록하기

---

## 다시 풀어 볼 문제
Bronze
- 2292 벌집                      : 층계 개념
- 2869 달팽이는 올라가고싶다        : 정수 Ceiling의 개념 Ceil(p/q) = (p+q-1)/q
- 2581 소수                      : 에라토스테네스의 체 개념
- 11653 소인수분해                : 소인수분해 개념
- 24267 알고리즘수업 6            : 시간복잡도 개념
- 2751 수정렬하기2                : O(nlogn) 정렬

Silver
- 24313 점근적접근1               : 빅O의 개념 -> 어떤 함수를 코드로 변환하는 능력
- 1436 영화감독 숌                : 연속한 숫자 찾기
- 7785 회사에 있는 사람            : set개념
- 18870 좌표압축                  : 정렬, 중복제거, 이분탐색 
- 11478 서로다른부분문자열의개수     : string_view 사용
- 4948 베르트랑 공준               : 에라토스테네스의 체 활용 + 누적합
- 13909 창문닫기                  : 아이디어 떠올리기 (완전제곱수)
- 4949 균형잡힌 세상               : 한줄 입력받기 + 스택 활용
- 2346 풍선 터뜨리기               : deque활용 + front나 back으로 값 확인할 때 빈 queue인지 잘 확인할 것
- 24511 queuestack               : 문제 이해가 어려움 + deque활용 -> 문제를 잘 읽고 해결하는 방향을 잘 찾을 것 
- 1010 다리놓기                   : 조합(combination) -> DP활용
- 2108 통계학                     : 평균, 중앙값, 최빈값, 범위
- 20902 영단어암기는괴로워          : 람다식으로 정렬순서 판별
- 24060 병합정렬2                 : 병합정렬 원리
- 14889 스타트와 링크              : 백트레킹 응용

Gold
- 11729 하노이탑쌓기               : 재귀 기본 원리
- 9663 N-Queen                   : 백트레킹
- 2580 스도쿠                     : 백트레킹
- 10986 나머지합                   : 누적합
- 11054 가장긴바이토닉부분수열       : DP 
- 2565 전깃줄                     : LIS
- 12865 평범한 배낭                : 어떤 기준을 가지고 DP를 돌릴지 알아야함
- 25683 체스판 다시 칠하기 2        : 누적합을 어디서 활용할 지 잘 생각해...
- 11401 이항계수3                  : 페르마의 소정리 + 나머지 연산은 곱셈에서도 가능
- 2110 공유기 설치                 : 문제 의도 파악 + 이분탐색
---

## 주요 알고리즘
1. 백트레킹
   - dfs(depth)
   - 종료조건은 하나 depth == (뽑고자 하는 갯수)
   - dfs 내부 1. 선택 2. 재귀 3. 되돌리기

2. DP
   핵심 개념 - 큰 문제를 작은 문제로 쪼개고 / 중복 계산을 저장해서 재사용
   - 조건, 수열을 파악하고 점화식을 잘 구하자.
   - 어떤 수열 등이 들어오면 초기값과 어떤 패턴이 있는 지 잘 파악하기.
   - dp[i] / dp[i][j] 가 무엇을 의미하는지 정확히

3. 탐욕법(Greedy Algorithm)
   핵심 개념 - 매 순간 가장 좋아 보이는 선택을 함 / 한 번 선택하면 되돌리지 않음 / 선택의 누적이 전체 최적해가 된다는 성질
   - 최대한, 최소한 이라는 문구가 자주 보임
   - 주로 문제에 탐욕법을 사용할 수 있는 조건을 제공함
   - 정렬한 뒤에 사용하는 경우가 많음

4. 누적합
   - "연속 구간"이 키워드/ 부분 구간 합, 부분 문자열, 연속된 구간, 정적 배열
   - 보통 O(n^2) 모든 구간 검사 시 시간 초과
   - 구간 합 조건을 두 누적합의 관계로 바꾼다.
   - S[0] = 0을 미리 포함 / 그래야 “앞에서부터 시작하는 구간”도 자동 처리됨

5. 분할정복
   - 1. 분할(Divide) → 2. 정복(Conquer, 재귀) → 3. 결합(Combine)
   - 보통 재귀 함수로 구현하며, 부분 문제들이 서로 중복되지 않을 때 사용 (중복되면 DP 고려)
   - 문제를 쪼개는 기준(보통 절반)과 더 이상 쪼갤 수 없는 상태인 Base Case를 명확히 정의하는 것이 관건

6. 이분탐색
   - 정렬된 데이터에서 탐색 범위를 절반씩 줄여나가며 원하는 값을 찾는 기법
   - 반드시 배열이나 리스트가 오름차순 또는 내림차순으로 정렬되어 있어야 함
   - $O(\log N)$ - 데이터가 10억 개라도 약 30번의 비교만으로 탐색 가능
   - 최댓값, 최솟값, "적어도 ~를 만족하는", "가능한 최대/최소"
   - low, high, mid 변수 설정
     while(low <= high) 조건에서 반복
     찾는 값이 mid보다 크면 low = mid + 1, 작으면 high = mid - 1