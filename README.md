# CodingTestPractice
코딩테스트 연습장 🧠💻

매일 2~3문제씩 꾸준히 풀면서,
난이도를 조금씩 올려가며 실력을 쌓기 위한 코딩테스트 연습 저장소입니다.

---

## 🎯 목표 (Goals)

- 하루 **2~3문제** 이상 꾸준히 풀이
- **쉬운 문제 → 중간 난이도 → 어려운 문제** 순으로 단계적으로 난이도 상승
- 단순 정답 코드가 아니라,  
  - 왜 이렇게 풀었는지  
  - 어떤 점에서 막혔는지  
  - 다음엔 어떻게 더 잘 풀 수 있을지  
  를 기록하면서 실력과 사고력을 함께 성장시키기
- 나의 학습 히스토리를 GitHub에 남겨 **성장 로그(타임라인)** 만들기

---

## 📅 학습 규칙 (Study Rules)

1. **매일 최소 2문제 이상** 풀기  
   - 여유가 되면 3문제 이상 도전
2. 한 문제를 풀 때:
   - 먼저 **손코딩/메모**로 접근 아이디어 생각하기
   - 바로 답을 찾지 말고, 최소 **10~20분은 스스로 고민**해 보기
3. 풀지 못한 문제는
   - 풀이를 본 뒤 **반드시 직접 다시 구현**해 보기
   - `다시 풀기` 체크를 남겨서 나중에 재도전
4. 같은 유형의 문제는 **3~5개 이상 연속으로** 풀어보기
5. 하루가 끝날 때, **오늘 배운 개념/실수 정리**를 짧게 기록하기

---

## 다시 풀어 볼 문제
Bronze
- 2292 벌집                      : 층계 개념
- 2869 달팽이는 올라가고싶다        : 정수 Ceiling의 개념 Ceil(p/q) = (p+q-1)/q
- 2581 소수                      : 에라토스테네스의 체 개념
- 11653 소인수분해                : 소인수분해 개념
- 24267 알고리즘수업 6            : 시간복잡도 개념
- 2751 수정렬하기2                : O(nlogn) 정렬

Silver
- 24313 점근적접근1               : 빅O의 개념 -> 어떤 함수를 코드로 변환하는 능력
- 1436 영화감독 숌                : 연속한 숫자 찾기
- 7785 회사에 있는 사람            : set개념
- 18870 좌표압축                  : 정렬, 중복제거, 이분탐색 
---

## 🔧 자료구조 사용 가이드 (언제 무엇을 쓸까?)

코딩테스트에서 자주 쓰는 자료구조들과  
**“어떤 상황에서 떠올리면 좋은지”**를 정리한 가이드입니다.

### 1. 배열 / 리스트 (Array / List)

- **언제 쓰면 좋은지**
  - 인덱스로 바로 접근해야 할 때 (예: `a[i]`)
  - 데이터 개수가 고정이거나, 삽입/삭제가 자주 일어나지 않을 때
  - 순차 탐색/전체 순회가 주된 작업일 때

- **대표 상황**
  - `N`개의 수가 주어지고, 누적 합, 최대/최소, 정렬 등 기본 연산
  - DP 테이블 (예: `dp[i]`, `dp[i][j]`)
  - 카운팅/마킹용 배열 (방문 체크, 등장 횟수 세기 등)

---

### 2. 연결 리스트 (Linked List)

> 코테에서 직접 구현해서 쓰는 경우는 많지 않지만, 개념은 알고 있기.

- **언제 쓰면 좋은지**
  - 중간 삽입/삭제가 매우 자주 일어나고, 순차 접근 위주일 때
  - 큐/스택의 내부 구현 개념을 이해할 때

- **대표 상황**
  - 직접 구현을 요구하는 문제 (덱, 리스트 시뮬레이션 등)
  - “배열로 구현하면 O(N)인데, 연결 리스트로 O(1)에 해결 가능” 같은 시뮬레이션 문제

---

### 3. 스택 (Stack)

- **키워드**: LIFO(Last In First Out), “뒤에서부터” 처리

- **언제 쓰면 좋은지**
  - 최근에 들어온 것부터 처리해야 할 때
  - 괄호 짝 맞추기, Undo(되돌리기) 같은 “되감기” 로직
  - DFS 재귀/반복 구현

- **대표 상황**
  - 괄호 유효성 검사, 균형잡힌 문자열
  - 후위 표기식, 수식 계산
  - “가장 가까운 이전/다음 큰 수” 같은 단조 스택 문제

---

### 4. 큐 / 덱 (Queue / Deque)

- **큐 (Queue)** – FIFO, 먼저 들어온 것부터 처리
  - **언제?**
    - **BFS** 구현
    - 시뮬레이션 (대기열, 주문 처리, 프린터 큐 등)
  - **대표 상황**
    - 그래프 최단 거리(BFS)
    - 여러 작업이 순서대로 처리되는 상황

- **덱 (Deque)** – 양쪽에서 삽입/삭제 가능
  - **언제?**
    - 양쪽에서 삽입/삭제가 자주 필요할 때
    - 슬라이딩 윈도우 최댓값/최솟값
  - **대표 상황**
    - 회전하는 큐, 카드 게임 시뮬레이션
    - 특정 구간의 최대/최소를 O(1)에 관리하는 문제

---

### 5. 우선순위 큐 / 힙 (Priority Queue / Heap)

- **키워드**: 항상 **최소값/최대값을 빠르게** 꺼내고 싶을 때

- **언제 쓰면 좋은지**
  - “현재까지 남은 것들 중 가장 작은/큰 것부터 처리”
  - 여러 개 중에서 “TOP K”만 필요할 때
  - 가중치가 있는 그래프에서 최단 거리 탐색 (다익스트라)

- **대표 상황**
  - 최솟값/최댓값을 계속 꺼내면서 처리하는 시뮬레이션
  - “가장 작업 시간이 짧은 것부터 처리” 같은 스케줄링 문제
  - 다익스트라 알고리즘 구현

---

### 6. 해시맵 / 해시셋 (HashMap / HashSet, Dictionary)

- **키워드**: 평균적으로 **O(1)**에 검색/삽입/삭제

- **언제 쓰면 좋은지**
  - “이 값이 이미 나왔는지?”를 빠르게 체크해야 할 때
  - 키-값 형태로 데이터를 관리할 때
  - 빈도수 세기, 개수 세기, 중복 제거

- **대표 상황**
  - 회원/사람 이름으로 출입 여부 체크 (enter/leave)
  - 두 배열/문자열 사이의 교집합, 중복 체크
  - 각 원소의 등장 횟수 카운팅 (예: 모드찾기, 가장 많이 나온 값)

---

### 7. 집합 / 정렬된 집합 (Set / Ordered Set)

> 언어별로 구현이 다름 (예: C++ `set`, Java `TreeSet` 등)

- **언제 쓰면 좋은지**
  - 데이터의 **중복을 허용하지 않으면서**, 항상 정렬된 상태를 유지하고 싶을 때
  - 현재 값보다 **바로 크거나/작은 값**을 찾고 싶을 때

- **대표 상황**
  - 순위, 순서, k번째 원소를 찾는 문제
  - 구간 내 최솟값/최댓값, 바로 이웃 값 찾기
  - “현재 값보다 큰 값 중 최소” 이런 조건이 자주 나올 때

---

### 8. 트리 / 이진 탐색 트리 (Tree / BST)

- **언제 쓰면 좋은지**
  - 계층 구조(트리 구조) 데이터를 다룰 때
  - 정렬된 데이터를 삽입/삭제하면서 유지해야 할 때 (균형 트리 기준)

- **대표 상황**
  - 계층적인 구조 (폴더, 조직도, 게임 내 스킬 트리 등)
  - 구간/범위를 기준으로 한 탐색 / 순위 통계 (이론 이해용)
  - 코테에서는 직접 균형 트리를 구현하기보단, **라이브러리(set/map)**로 대체되는 경우가 많음

---

### 9. 그래프 (Graph)

- **표현 방식**
  - 인접 리스트 (Adjacency List)
  - 인접 행렬 (Adjacency Matrix)

- **언제 쓰면 좋은지**
  - “정점(노드) + 간선(연결)” 구조일 때 (예: 도시/길, 사람/관계, 웹 페이지/링크)
  - 이동, 연결, 경로 찾기 문제가 나올 때

- **대표 상황**
  - BFS/DFS로 탐색하는 모든 그래프 문제
  - 최단 경로, 연결 요소 개수, 사이클 검사
  - 맵/미로에서 상하좌우 이동이 아니라, **특정 연결 관계**로 이동하는 경우

---

### 10. 세그먼트 트리 / 펜윅 트리 (Segment Tree / Fenwick Tree)

- **언제 쓰면 좋은지**
  - 배열에서
    - “구간 합 / 구간 최댓값 / 구간 최솟값” 등을
    - **자주** 물어보면서
    - 중간에 원소 값도 **자주 변경**될 때

- **대표 상황**
  - “N, Q가 크고 (예: 10^5 이상), 구간 질의 + 업데이트가 같이 나오는 문제”
  - 예: 
    - `1 x y` → x번째 값을 y로 바꾸기  
    - `2 l r` → 구간 [l, r]의 합 구하기

---

### 11. 유니온 파인드 (Disjoint Set / Union-Find)

- **키워드**: 서로소 집합, 합치기 & 같은 집합인지 확인

- **언제 쓰면 좋은지**
  - 여러 개의 요소들이 “같은 그룹인지” 계속 판단해야 할 때
  - 간선을 하나씩 추가하면서 **연결 여부**를 확인할 때
  - MST(Kruskal) 같은 알고리즘에서 자주 사용

- **대표 상황**
  - “두 사람/노드가 같은 집합(네트워크)에 속해 있는지?”를 자주 물어볼 때
  - 인터넷/네트워크 연결, 친구 관계, 팀 배정 문제
  - 그래프에서 사이클 검사, 연결 요소 관리

---

### 12. 문자열 관련 구조 (문자열 + 추가 구조)

> 코테에서는 **문자열 자체 + 보조 자료구조** 조합이 많음.

- **언제 쓰면 좋은지**
  - 패턴 매칭, 문자열 압축, 중복 문자열 처리, 부분 문자열 관련 문제
- **자주 함께 쓰이는 조합**
  - 문자열 + 해시맵: 문자/부분 문자열 등장 횟수, 아나그램 판별
  - 문자열 + 스택: 괄호, 태그, 중첩 구조 처리
  - 문자열 + 투 포인터: 부분 문자열 길이/조건 만족 구간 찾기

---

### 💡 자료구조 선택 시 빠른 체크 포인트

- **정렬 유지 + 중복 허용 X** → `set` / 정렬된 자료구조
- **최솟값/최댓값 자주 뽑기** → `priority_queue` (힙)
- **존재 여부 / 빈도 체크** → `hash map / hash set`
- **구간 합/최댓값 + 업데이트** → `segment tree` / `fenwick tree`
- **그래프 탐색** → `adjacency list` + `BFS/DFS`
- **그룹/연결 여부 관리** → `union-find`
